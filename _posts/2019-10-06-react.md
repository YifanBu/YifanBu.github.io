---
title: "Front-End Framework: React"
date: 2019-10-06
tags: [React]
header:
image:
excerpt: "Framework, Web Development, Front-End"
toc: true
toc_label: "Table of Contents"
toc_sticky: true
toc_icon: "cog"
---

# Intro

## How does React Work?

React creates a *VIRTUAL DOM* in memory, where it does all the necessary manipulating, before making the changes in the browser DOM. React only changes what needs to be changed.

## Setup

`npx create-react-app [Project Name / .] --scripts-version 2.1.2`

## File Structure

*index.js*: 

```javascript
// Import the React and ReactDom Libraries
import React from 'react';
import ReactDOM from 'react-dom';

// Create a react component
const App = () => {
  return <div>Hi there!</div>;
};

// Take the react component and show it on the screen
ReactDOM.render(
  <App />, 
  document.querySelector('#root')
);
```

# JSX

## Differences between JSX and HTML

- Adding custom styling to an element uses different syntax
- Adding a class to an element uses different syntax
- JSX can reference JS variables (the most important feature)

## Converting Styling to JSX Format 

- HTML: `<div style="background-color:red;"></div>`
- JSX: `<div style={{ backgroundColor:'red' }}></div>`

- HTML: `style="background-color:blue; color: white;"`
- JSX: `style={{ backgroundColor: 'blue', color: 'white' }}`

## Class vs ClassName

*class* and *for* are forbidden property names in JSX:

- HTML: `<label class="label" for="name">Enter name:</label>`
- JSX: `<label className="label" htmlFor="name">Enter name:</label>`

## Referencing JS Variables in JSX

`{variable}`

`{function()}`

### Values JSX Can't Show

*Objects* are not valid as a React child.

# Styling

## Semantic UI

*index.html*:

```html
<head>
  <link rel="stylesheet" href="url from semantic ui cdn"/>
</head>
```

## Specifying Images in JSX

**faker.js**: generate massive amounts of realistic fake data in Node.js and browser.

`npm install --save faker`

`import faker from 'faker';`

```html
<img alt="avatar" scr={faker.image.avatar()} />
```

# Components

Components are **independent** and **reusable** bits of code. They serve the same purpose as JavaScript functions, but work in isolation and returns *HTML* elements via a render function.

A component is a Function or a Class that:
- produces HTML to show the user (using JSX)
- handles feedback from the user (using Event Handlers)

## 3 Tenets of Components

1. **Nesting**: A component can be shown inside of another
2. **Reusability**: Components can be easily reused through out application
3. **Configuration**: We should be able to configure a component when it is created

## Component Nesting

ComponentName.js: `export default ComponentName`

index.js: 

```javascript
import ComponentName from './ComponentName'

const App = () => {
  return (
  <div className="ui container">
    <ComponentName />
    <ComponentName />
    <ComponentName />
    <ComponentName />
    <ComponentName />
  <div/>
  );
};
```

## Class-Based Components

```javascript
class App extends React.Component {
  render() {
    return <div>Latitude: </div>;
  }
}
```

3 benefits:

1. Easier code organization
2. 'state': Easier to handle user input
3. lifecycle events: Easier to do things when app first starts

Function Component's Time Line:

JS file loaded by browser -> App Component gets created -> We call geo-location service -> App returns JSX, gets rendered to page as HTML -> ... -> We get result of geo-location

Class-based Component's Time Line:

JS file loaded by browser -> App Component gets created -> We call geo-location service -> App returns JSX, gets rendered to page as HTML -> ... -> We get result of geo-location -> **Tell the component to re-render itself with this new information**

## Rules of Class Components

- Must be a JavaScript Class
- Must extend React.Component
- Must define a 'render' method that returns some amount of JSX

# Prop

Props are **objects** passed from a parent component to a child component via HTML attributes. The goal is to customize or configure a child component.

## Passing and Receiving Props

- Providing props from parent to child:
```javascript
const App = () => {
  return (
    <ComponentName propName1=propValue1 propName2=propValue2 propName3=propValue3 />
  );
};
```

- Consuming props:

```javascript
const ComponentName = props => {
  return (
    {props.propName1}
    {props.propName2}
    {props.propName3}
  )
};
```

## Custom Children

- Passing child component to parent component:

```javascript
const App = () => {
  return (
    <ParentComponent>
      <ChildComponent propName1=propValue1 propName2=propValue2 propName3=propValue3 />
    </ParentComponent>
  );
};
```

- Consuming children:

```javascript
const ParentComponent = props => {
  return (
    {props.children}
  )
};
```

## Specifying Default Props

```javascript
const ComponentName = props => {
  return (
    {props.message}
  )
};

ComponentName.defaultProps = {
  message: 'Loading...'
};
```

## Communicating from Child to Parent

Parent:

```javascript
import SearchBar from './SearchBar';

class App extends React.Component {
  onSearchSubmit(term) {
    console.log(term);
  }

  render() {
    return (
      <Search onSubmit={this.onSearchSubmit} />
    )
  }
}
```

Child:

```javascript
class SearchBar extends React.Component {
  onFormSubmit = event => {
    event.preventDefault();

    this.props.onSubmit(this.state.term);
  }
}
```


# State

React components has a built-in state object. The state object is where you store property values that belongs to the component. When the state object changes, the component re-renders.

## Rules of State

- Only usable with class components
- 'State' is a JS object that contains data relevant to a component
- Updating 'state' on a component causes the component to instantly re-render
- State must be initialized when a component is created
- **State can only be updated using the function 'setState'**

## Initializing State Through Constructors

```javascript
class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = { lat: null };
  }
  
  render() {
    return <div>Latitude: {this.state.lat} </div>;
  }
}
```

## Updating State Properties

```javascript
class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = { lat: null, errorMessage: '' };

    window.navigator.geolocation.getCurrentPosition(
      position => {
        this.setState({ lat: position.coords.latitude }); // the only way to update state!!!
      },
      err => {
        this.setState({ errorMessage: err.message });
      }
    );
  }
  
  render() {
    return (
      <div>
        Latitude: {this.state.lat} 
        <br />
        Error: {this.state.errorMessage}
      </div>
    );
  }
}
```

## App Lifecycle

... -> We get result of geolocation -> We update state object with a call to 'this.setState' -> React sees that we updated the state of a component -> React calls 'render' method a second time -> Render method returns the updated JSX


# Lifecycle Methods

Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.

The three phases are: Mounting, Updating, and Unmounting.

## Component Lifecycle

A component lifecycle method is a function that we can optionally define inside of our class based components. If we decide to implement these methods, they will be called automatically by react at certain points during a component lifecycle.  

**constructor** --> **render** -Content visible on screen-> **componentDidMount** -Sit and wait for updates-> **componentDidUpdate** -Sit and wait until this component is not longer shown-> **componentWillUnmount**

- **componentDidMount()**: being called immediately after the component shows up on the screen
- **componentDidUpdate()**: being called automatically after the component updates
- **componentWillUnmount()**: being called automatically if the component no longer shows

## Why Lifecycle Methods

- constructor(): one-time setup
- render(): avoid doing anything besides returning JSX
- componentDidMount(): good place to do data loading
- componentDidUpdate(): good place to do more data loading when state/props change
- componentWillUnmount(): good place to cleanup(especially for non-React stuff)


## Alternate State Initialization

```javascript
class App extends React.Component {
/*  
  constructor(props) {
    super(props);

    this.state = { lat: null, , errorMessage: '' };
  }
*/

  state = { lat: null, errorMessage: '' }

  render() {
    return <div>Latitude: {this.state.lat} </div>;
  }
}
```

## Passing State as Props

We can take state from one component and pass it as a prop down to the child.

Every time we call setState, the component will also render any children that it is showing as well.

## Avoiding Conditionals in Render

Try to avoid having multiple *return* statements inside the *render* method. Put the statements inside a *renderContent*:

```javascript
renderContent() {

}

render() {
  return (
    {this.renderContent()}
  )
}
```


# Handling User Input with Forms and Events

React events are written in camelCase syntax. React event handlers are written inside curly braces:

- JSX: `onClick={shoot}` 
- HTML: `onclick="shoot()"`

Handling forms is about how you handle the data when it changes value or gets submitted.

## Event Prop

- **onClick**: being called automatically when user clicks on something
- **onChange**: user changes text in an input
- **onSubmit**: user submits a form

## Creating Event Handlers

- Passing a callback function to the prop:

```javascript
class SearchBar extends React.Component {
  onInputChange(event) {
    console.log(event.target.value);
  }

  render() {
    return (
      <input type="text" onChange={this.onInputChange} />
    )
  }
}
```

- Inline Event Handler:

```javascript
class SearchBar extends React.Component {
  render() {
    return (
      <input type="text" onChange={ (event) => console.log(event.target.value) } />
    )
  }
}
```

## Uncontrolled vs Controlled Elements

Storing information inside of components on state property as opposed to storing information inside the dom. The idea is to make sure that the react application instead of HTML side driving and storing all of the data.

- React: `state -> { term: 'hi there' }`
- DOM: `<input value={"go look at state to get current value"} />`


```javascript
class SearchBar extends React.Component {
  state = { term: '' };

  render() {
    return (
      <input
       type="text" 
       value={this.state.term}
       onChange={(event) => this.setState({ term: event.target.value })} 
       />
    )
  }
}
```

## Handling Form Submittal

Default: the entire page refreshes automatically any time the user presses 'enter'.

 TypeError: Cannot read property 'state' of undefined:

```javascript
  onFormSubmit(event) {
    event.preventDefault();

    console.log(this.state.term);
  }
```

Solving context issues:

```javascript
class SearchBar extends React.Component {
  onFormSubmit = (event) => {
    event.preventDefault();

    console.log(this.state.term);
  }

  render() {
    return (
      <form onSubmit={this.onFormSubmit} className="ui form">
    )
  }
}
```

# Making API Requests

As a library, react is only about showing content to users and handling user interaction. To make a network request to get some information is the job of some separate piece of code.

## Axios vs Fetch

- **axios**: 3rd party package
- **fetch**: function built into modern browsers

install Axios: `npm install --save axios`

## Making a Request

`axios.get(ag1, ag2);`

- ag1: the address that we want to make a request to
- ag2: an object that has a bunch of options that will customize the request

```javascript
import axios from 'axios';

class App extends React.Component {
  onSearchSubmit(term) {
    axios.get('https://api.unsplash.com/search/photos', {
      params: { query: term },
      headers: {
        Authorization: ''
      }
    });
  }
}
```

## Handling Request with Async Await

Whenever we make a request with Axios, it returns an object called a promise. A promise is an object that will essentially give us a notification when the request is completed. 

```javascript
import axios from 'axios';

class App extends React.Component {
  
  state = { image: [] };
  
  onSearchSubmit = async (term) => {
    const response = await axios
      .get('https://api.unsplash.com/search/photos', {
        params: { query: term },
        headers: {
          Authorization: 'Client ID jdskfhivasd'
        }
      });

    this.setState({ images: response.data.results });
  }
}
```

## Creating Custom Clients

apiName.js:

```javascript
import axios from 'axios';

export default axios.create({
  baseURL: 'https://api.unsplash.com',
  headers: {
    Authorization: ''
  }
});
```

# Rendering Lists of Records

Creating a component called *ImageList* to render out a list of images.

ImageList.js:

```javascript
import React from 'react';

const ImageList = (props) => {
  const images = props.images.map( (image) => {
    return <img alt={description} key={id} src={url.regular} />
  });
  
  return <div>{images}</div>;
};

export default ImageList;
```

# Navigation with React Router

CRUD: Create, Read, Update, Destroy

`npm install --save react-router-dom`

- react-router-dom: Navigation for dom-based apps
- react-router-native: Navigation for react-native apps

`import { BrowserRouter, Route } from 'react-router-dom'`

React Router only cares about **a particular part** of the full URL:

- localhost:3000 -> /
- localhost:3000/pageone -> /pageone

**exact**: extractedPath === path











<!--
# Using Ref's for DOM Access



# Authentication with React



# REST-Based React Apps



# React Portals



# Implementing Streaming Video



# The Context System with React



# Replacing Redux with Context



# Hooks with Functional Components



# More Fun with Hooks


# React Testing

-->










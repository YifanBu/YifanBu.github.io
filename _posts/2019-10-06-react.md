---
title: "Modern React with Redux"
date: 2019-10-06
tags: [React, Redux]
header:
image:
excerpt: "Framework, Web Development, Front-End"
toc: true
toc_label: "Table of Contents"
toc_sticky: true
toc_icon: "cog"
---

# Intro

## How does React Work?

React creates a *VIRTUAL DOM* in memory, where it does all the necessary manipulating, before making the changes in the browser DOM. React only changes what needs to be changed.

## Setup

`npx create-react-app [Project Name / .] --scripts-version 2.1.2`

## File Structure

*index.js*: 

```javascript
// Import the React and ReactDom Libraries
import React from 'react';
import ReactDOM from 'react-dom';

// Create a react component
const App = () => {
  return <div>Hi there!</div>;
};

// Take the react component and show it on the screen
ReactDOM.render(
  <App />, 
  document.querySelector('#root')
);
```

# JSX

## Differences between JSX and HTML

- Adding custom styling to an element uses different syntax
- Adding a class to an element uses different syntax
- JSX can reference JS variables (the most important feature)

## Converting Styling to JSX Format 

- HTML: `<div style="background-color:red;"></div>`
- JSX: `<div style={{ backgroundColor:'red' }}></div>`

- HTML: `style="background-color:blue; color: white;"`
- JSX: `style={{ backgroundColor: 'blue', color: 'white' }}`

## Class vs ClassName

*class* and *for* are forbidden property names in JSX:

- HTML: `<label class="label" for="name">Enter name:</label>`
- JSX: `<label className="label" htmlFor="name">Enter name:</label>`

## Referencing JS Variables in JSX

`{variable}`

`{function()}`

### Values JSX Can't Show

*Objects* are not valid as a React child.

# Styling

## Semantic UI

*index.html*:

```html
<head>
  <link rel="stylesheet" href="url from semantic ui cdn"/>
</head>
```

## Specifying Images in JSX

**faker.js**: generate massive amounts of realistic fake data in Node.js and browser.

`npm install --save faker`

`import faker from 'faker';`

```html
<img alt="avatar" scr={faker.image.avatar()} />
```

# Components

Components are **independent** and **reusable** bits of code. They serve the same purpose as JavaScript functions, but work in isolation and returns *HTML* elements via a render function.

A component is a Function or a Class that:
- produces HTML to show the user (using JSX)
- handles feedback from the user (using Event Handlers)

## 3 Tenets of Components

1. **Nesting**: A component can be shown inside of another
2. **Reusability**: Components can be easily reused through out application
3. **Configuration**: We should be able to configure a component when it is created

## Component Nesting

ComponentName.js: `export default ComponentName`

index.js: 

```javascript
import ComponentName from './ComponentName'

const App = () => {
  return (
  <div className="ui container">
    <ComponentName />
    <ComponentName />
    <ComponentName />
    <ComponentName />
    <ComponentName />
  <div/>
  );
};
```

## Class-Based Components

```javascript
class App extends React.Component {
  render() {
    return <div>Latitude: </div>;
  }
}
```

3 benefits:

1. Easier code organization
2. 'state': Easier to handle user input
3. lifecycle events: Easier to do things when app first starts

Function Component's Time Line:

JS file loaded by browser -> App Component gets created -> We call geo-location service -> App returns JSX, gets rendered to page as HTML -> ... -> We get result of geo-location

Class-based Component's Time Line:

JS file loaded by browser -> App Component gets created -> We call geo-location service -> App returns JSX, gets rendered to page as HTML -> ... -> We get result of geo-location -> **Tell the component to re-render itself with this new information**

## Rules of Class Components

- Must be a JavaScript Class
- Must extend React.Component
- Must define a 'render' method that returns some amount of JSX

# Prop

Props are **objects** passed from a parent component to a child component via HTML attributes. The goal is to customize or configure a child component.

## Passing and Receiving Props

- Providing props from parent to child:
```javascript
const App = () => {
  return (
    <ComponentName propName1=propValue1 propName2=propValue2 propName3=propValue3 />
  );
};
```

- Consuming props:

```javascript
const ComponentName = props => {
  return (
    {props.propName1}
    {props.propName2}
    {props.propName3}
  )
};
```

## Custom Children

- Passing child component to parent component:

```javascript
const App = () => {
  return (
    <ParentComponent>
      <ChildComponent propName1=propValue1 propName2=propValue2 propName3=propValue3 />
    </ParentComponent>
  );
};
```

- Consuming children:

```javascript
const ParentComponent = props => {
  return (
    {props.children}
  )
};
```

# State

React components has a built-in state object. The state object is where you store property values that belongs to the component. When the state object changes, the component re-renders.

## Rules of State

- Only usable with class components
- 'State' is a JS object that contains data relevant to a component
- Updating 'state' on a component causes the component to instantly re-render
- State must be initialized when a component is created
- **State can only be updated using the function 'setState'**

## Initializing State Through Constructors

```javascript
class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = { lat: null };
  }
  
  render() {
    return <div>Latitude: {this.state.lat} </div>;
  }
}
```

## Updating State Properties

```javascript
class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = { lat: null, errorMessage: '' };

    window.navigator.geolocation.getCurrentPosition(
      position => {
        this.setState({ lat: position.coords.latitude }); // the only way to update state!!!
      },
      err => {
        this.setState({ errorMessage: err.message });
      }
    );
  }
  
  render() {
    return (
      <div>
        Latitude: {this.state.lat} 
        <br />
        Error: {this.state.errorMessage}
      </div>
    );
  }
}
```

## App Lifecycle

... -> We get result of geolocation -> We update state object with a call to 'this.setState' -> React sees that we updated the state of a component -> React calls 'render' method a second time -> Render method returns the updated JSX



# Lifecycle Methods

Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.

The three phases are: Mounting, Updating, and Unmounting.




# Handling User Input with Forms and Events

React events are written in camelCase syntax. React event handlers are written inside curly braces:

`onClick={shoot}` instead of `onclick="shoot()"`.

Handling forms is about how you handle the data when it changes value or gets submitted.





# Making API Requests with React



# Rendering Lists




# Using Ref's for DOM Access




# Redux



# Integrating React with Redux



# Async Actions with Redux Thunk



# Redux Store Design



# Navigation with React Router



# Authentication with React



# Redux Dev Tools



# Handling Forms with Redux Form



# REST-Based React Apps



# React Portals



# Implementing Streaming Video



# The Context System with React



# Replacing Redux with Context



# Hooks with Functional Components



# More Fun with Hooks



# React Testing




---
title: "ECMAScript 6"
date: 2019-09-10
tags: [JavaScript]
header:
image:
excerpt: "Front-End, Web Development"
toc: true
toc_label: "Table of Contents"
toc_sticky: true
toc_icon: "cog"
---

# Variable Declarations

Variables declared with var in ES5 are **function-scoped**:

```javascript
var i = 23;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

Variables declared with let and const in ES6 are **block-scoped**. A block is all the code that is wrapped between the curly braces. Variables declared with *let* and *const* are only valid or accessible by the code that are inside of the same block. 

```javascript
let i = 23;

for (let i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 23
```

# Blocks and IIFEs

IIFE in ES5:

```javascript
(function() {
  var c = 3;
})();

console.log(c); // Uncaught ReferenceError: c is not defined(...)
```

IIFE in ES6:

```javascript
{
  const a = 1;
  const b = 2;
}

console.log(a + b); // Uncaught ReferenceError: a is not defined(...)
```

# Strings

template literals in ES6:

```javascript
console.log(`This is ${firstName} ${lastName}. He was born in ${yearOfBirth}. Today. he is ${calcAge(yearOfBirth)} years old.`);
```

string methods in ES6:

```javascript
const n = `${firstName} ${lastName}`;
console.log(n.startsWith('j')); // case sensitive
console.log(n.endsWith('j'));
console.log(n.includes('j'));
console.log(`${firstName}`.repeat(5));
```

# Arrow Functions: Basics

```javascript
const years = [1990, 1965, 1982, 1937];

// ES5
var ages5 = years.map(function(el) {
  return 2019 - el;
});
console.log(ages5);


// ES6
let ages6 = years.map(el => 2019 - el);
console.log(ages6);
```

# Arrow Functions: 'this'

The biggest advantage of using arrow functions is that they share the surrounding **'this'** keyword. Arrow functions do not have their own **'this'** keyword. They simply use the **'this'** keyword of the function they are written in. So we say they have a lexical **'this'** variable.

There is a weird part about JS. Only the method call, the **'this'** keyword actually points to that object. But in a regular function call, the **'this'** keyword will always point to the global object:

```javascript
// ES5
var box5 = {
  color: 'green',
  position: 1,
  clickMe: function() {
    document.querySelector('.green').addEventListener('click', function() {
      var str = 'This is box number ' + this.position + ' and it is ' + this.color; 
      /*clickMe is a function attached to the box5 object. So it's a method call. The callback function we have here is not a method. It's a regular function call. So 'this' keyword here does not point to the box5 object. It points to the global(Window) object, where position and color are not defined. */
      alert(str);
    });
  }
}
box5.clickMe(); // 'This is box number undefined and it is undefined'

// a very common pattern to avoid the hack
var box5 = {
  color: 'green',
  position: 1,
  clickMe: function() {

    var self = this; // create a new variable in the method call and store the 'this' variable in that new variable
    document.querySelector('.green').addEventListener('click', function() {
      var str = 'This is box number ' + self.position + ' and it is ' + self.color;
      alert(str);
    });
  }
}
box5.clickMe();
```

The **best practice** is to always use arrow functions when you need to preserve the value of 'this' keyword, as we did here:

```javascript
const box6 = {
  color: 'green',
  position: 1,
  clickMe: function() {
    document.querySelector('.green').addEventListener('click', () => {
      var str = 'This is box number ' + this.position + ' and it is ' + this.color;
      alert(str);
    }); // the arrow function shares the 'this' keyword with its surroundings, which is the clickMe method
  }
}
box6.clickMe();
```
We have to be really careful with arrow functions so that we don't lose track of what the **'this'** keyword actually points to. Not something that we want:

```javascript
var box66 = {
  color: 'green',
  position: 1,
  clickMe: () => {
    // the method here also shares the lexical 'this' keyword from its surroundings, which is the global context
    document.querySelector('.green').addEventListener('click', () => {
      var str = 'This is box number ' + this.position + ' and it is ' + this.color;
      alert(str);
    });
  }
}
box66.clickMe(); // 'This is box number undefined and it is undefined'
```

Let's create a function constructor in order to create a Person object:

```javascript
function Person(name) {
  this.name = name;
}

// add a method to the prototype property of the Person, so the objects created through the Person function constructor inherit the method:
Person.prototype.myFriends5 = function(friends) {
  // here, if there is a 'this', it points to the object John
  var arr = friends.map(function(el) 
  {
    return this.name + ' is friends with ' + el;
    // in the anonymous function, 'this' points to the global object   
  });

  console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
new Person('John').myFriends5(friends);

// another cool trick we could fix the problem here
// call, bind & apply allow us to define the 'this' variable manually
// bind creates a copy of the function
// call actually calls it immediately
Person.prototype.myFriends5 = function(friends) {
  var arr = friends.map(function(el) 
  {
    return this.name + ' is friends with ' + el;
  }.bind(this)); // outside the anonymous function, we still have access to the 'this' variable

  console.log(arr);
}
```

Look how we solve it in ES6:

```javascript
Person.prototype.myFriends6 = function(friends) {

  var arr = friends.map(el => `${this.name} is friends with + ${el}`);

  console.log(arr);
}

new Person('Mike').myFriends6(friends);
```

# Destructuring

Destructuring is a very convenient way to **extract data** from a data structure like an object or an array:

```javascript
// ES5
var john = ['John', 26];
var name = john[0];
var age = john[1];

// ES6
const [name, age] = ['John', 26];


// ES6
const obj = {
  firstName: 'John',
  lastName: 'Smith'
};
const {firstName: a, lastName: b} = obj;


// return multiple values from a function
function calcAgeRetirement(year) {
  const age = new Date().getFullYear() - year;
  return [age, 65 - age];
}
const [age2, retirement] = calcAgeRetirement(1990);
```

# Arrays

New Array methods in ES6:

**Array.from()** can transform the node list to an array.

In ES5, we use *forEach* and *map* method to loop through an array. The problem is we cannot use *break* or *continue* statement. In ES6, we can use **for of** method with *break* or *continue* statement in the loop:

```javascript
for (const cur of boxesArr6) {
  if (cur.className.includes('blue')) {
    continue;
  }
  cur.textContent = 'I changed to blue!';
}
```

```javascript
var ages = [12, 17, 8, 21, 14, 11];

// ES5: .map() & .indexOf()
var full = ages.map(function(cur) {
  return cur >= 18;
});

full.indexOf(true);
ages[full.indexOf(true)];


// ES6: .findIndex() & .find()
ages.findIndex(cur => cur >= 18);

ages.find(cur => cur >= 18);

```

# The Spread Operator

The Spread Operator is a very convenient way to **expand elements of an array** in places like arguments and function calls.

```javascript
function addFourAges (a, b, c, d) {
  return a + b + c + d;
}
var sum1 = addFourAges(18, 30, 12,21);

// ES6
var ages = [18, 30, 12, 21];
const sum3 = addFourAges(...ages);

// Merge two arrays in ES6:
const familySmith = ['John', 'Jane', 'Mark'];
const familyMiller = ['Marry', 'Bob', 'Ann'];
const bigFamily = [...familySmith,'Lily', ...familyMiller];
```

# Rest Parameter

Rest Parameter allows us to pass **an arbitrary number of** arguments into a function by receiving a couple of single values and transforming them into an array.

```javascript
// ES6
function isFullAge6(...years) {
  years.forEach(cur => console.log((2016 - cur) >= 18));
}
isFullAge5(1990, 1999, 1965);
```

# Default Parameter

Default Parameter allows us to **preset one or more parameters** of a function if we want them to have default values.

```javascript
// ES6
function SmithPerson(firstName, yearOfBirth, lastName = 'Smith', nationality = 'american') {
  this.firstName = firstName;
  this.lastName = lastName;
  this.yearOfBirth = yearOfBirth;
  this.nationality = nationality;
}
```

# Map

A map is a new **key-value data structure** in ES6.

In object, keys are limited to strings. In maps, we can use any kind of primitive value(number, string, boolean, function, object) for the keys. It is very easy to loop through Maps and manipulate data with Maps. Maps are better than Objects to create hash maps.

```javascript
const question = new Map(); // const x = new Map();

// use x.set(key, value) to define a new key-value pair
question.set('question', 'What is the official name of the latest major JS version?');
question.set(1 , 'ES5');
question.set(2 , 'ES6');
question.set(3 , 'ES2015');
question.set(4 , 'ES7');
question.set('correct' , 3);
question.set(true, 'Correct answer');
question.set(false, 'Wrong, please try again.');

question.get('question'); // x.get(key); retrieve the value of map
question.size; // 8
question.delete(4); // x.delete(key);

if (question.has(4)) {
  question.delete(4);
}

question.clear(); // Map {}

// use x.forEach() to loop
question.forEach((value, key) => console.log(`This is ${key}, and it's set to ${value}`));

// use the 'for-of' to loop
// Map destructuring
for (let [key, value] of question.entries()) {
  if (typeof(key) === 'number') {
    console.log(`Answer ${key}: ${value}`);
  }
}

const ans = parseInt(prompt('Write the correct answer'));
question.get(ans === question.get('correct'));
```

# Classes

Class is syntactic sugar over the way we do prototype inheritance in ES5. Classes make it easier to  create objects and to implement inheritance.

Function Constructor in ES5:

```javascript
var Person5 = function(name, yearOfBirth, job) {
  this.name = name;
  this.yearOfBirth = yearOfBirth;
  this.job = job;
}

Person5.prototype.calculateAge = function() {
  var age = new Date().getFullYear() - this.yearOfBirth;
  console.log(age);
}

var john5 = new Person5('John', 1990, 'teacher');

```

Unlike function constructors, the class definitions are not hoisted. We need to first implement a class, and later in our code, we can start using it.

We can only add methods to classes but not properties.

```javascript
class Person6 {
  constructor (name, yearOfBirth, job) {
    this.name = name;
    this.yearOfBirth = yearOfBirth;
    this.job = job;
  }

  calculateAge() {
    var age = new Date().getFullYear - this.yearOfBirth;
    console.log(age);
  }

  static greeting() {
    console.log('Hey there!');
  }
  // static methods: methods that are simply attached to the class, but not inherited by the class instances.
}

// create an instance of the class
const john6 = new Person6('John', 1990, 'teacher');
Person6.greeting();
```

# Classes with Subclasses

In ES6, Subclasses implement inheritance between classes.

```javascript
// ES5
var Person5 = function(name, yearOfBirth, job) {
  this.name = name;
  this.yearOfBirth = yearOfBirth;
  this.job = job;
}

Person5.prototype.calculateAge = function() {
  var age = new Date().getFullYear() - this.yearOfBirth;
  console.log(age);
}

var Athlete5 = function(name, yearOfBirth, job, olympicGames, medals) {
  Person5.call(this, name, yearOfBirth, job);
  this.olympicGames =olympicGames;
  this.medals = medals;
}

// 'new' operator: create a new instance
// when creating a new athlete object, 'new' creates a new empty object, calls the athlete function constructor, and sets 'this' to the newly created empty object
Athlete5.prototype = Object.create(Person5.prototype); // Person5 is a super class, Athlete5 is a subclass of Person5

var johnAthlete5 = new Athlete5('John', 1990, 'swimmer', 3, 10);

// ES6
class Person6 {
  constructor (name, yearOfBirth, job) {
    this.name = name;
    this.yearOfBirth = yearOfBirth;
    this.job = job;
  }

  calculateAge() {
    var age = new Date().getFullYear - this.yearOfBirth;
    console.log(age);
  }
}

class Athlete6 extends Person6 {
  constructor(name, yearOfBirth, job, olympicGames, medals) {
    super(name, yearOfBirth, job);
    this.olympicGames = olympicGames;
    this.medals = medals;
  }

  wonMetal() {
    this.medals++;
    console.log(this.medals);
  }
} 

const johnAthlete6 = new Athlete6('John', 1990, 'swimmer', 3, 10);

johnAthlete6.wonMetal();
johnAthlete6.calculateAge();
```